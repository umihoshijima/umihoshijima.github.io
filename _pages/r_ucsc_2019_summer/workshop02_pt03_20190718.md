---
permalink: /r_ucsc_2019_summer/pt3/
title: "Introduction to ggplot"
header:
  overlay_image: /assets/images/ant_diving_green.jpg
toc: true
toc_sticky: true
---

[Back to main workshop page]({{ site.url }}/r_ucsc_2019_summer/)

# Objectives:
> * install and load packages to
> * Compare ggplot to "base plot"
> * Learn how to make simple plots in ggplot2.
> * Expand plots based on the
> * Using different colors, grouping data, subplots.



# What is a package?

- An R package extends the functionality of R beyond its out-of-the-box capabilities. Packages exist for all sorts of things (stats,
- Last I checked, there are over [12,000 official packages for R](https://cran.r-project.org/web/packages/available_packages_by_name.html). This is quite overwhelming, and generally you install what you need as you go. For inspiration, select packages are sorted into groups by function at the [CRAN Task View](https://cran.r-project.org/web/views/).
- The two packages were are using here are part of the [Tidyverse]( https://www.tidyverse.org), a group of packages that are produced by the same team and work well together. These are generally great complementary packages for data science.

# What is ggplot?

- `ggplot2` is the package, `ggplot` is the main function, but as you see we will use quite a few functions from `ggplot2` in this lesson.
- The 'gg' stands for grammar of graphics.  
- A syntax for making plots and figures.
- Defines components of a figure.
- Coherent, consistent syntax for a range of plotting.


# Getting Started with ggplot:

Let's install and load our `ggplot2` package.  We'll also be using some dplyr here as well.

~~~
install.packages("ggplot2")
install.packages("dplyr")
library(ggplot2)
library(dplyr)
~~~
{: .r}

Then, import the `mammals` dataset. This is a subset of a *["species-level database of extant and recently extinct mammals](http://esapubs.org/archive/ecol/E090/184/)*. You can download it [HERE](https://seltmann.github.io/2018-04-05-ucsb/data/mammals.csv).

~~~
#loading mammals dataset for ggplot exercise:
setwd("~/Desktop/workshop/data")
mammals <- read.csv("mammals.csv", head=T)

~~~
{: .r}



Let's compare two plots of the same data.

##Here are the codes to make plots of body size vs. litter size:

~~~
plot(adult_head_body_len_mm ~ adult_body_mass_g, data=mammals)
~~~
{: .r}
![plot]({{ site.url }}/assets/r_workshop_2019/first_plot.jpg.jpeg)


OR



~~~
ggplot(data=mammals, aes(x=adult_body_mass_g, y=adult_head_body_len_mm)) + geom_point()
~~~
{: .r}

![plot]({{ site.url }}/assets/r_workshop_2019/first_plot_ggplot.jpg.jpeg)

Although the plots look similar, we can see differences in the basic structure of the code, and some of the default formatting.  The first is obvious, in which `plot(y~x)` means _"plot y with respect to x"_, which is fairly standard in many functions in R (e.g. statistics).  That second line of code probably looks a little like gibberish.  But it won't help you get gold out of Gringott's until you understand all its parts.

## So why do we need another plotting method, to make the same plot?


Both `plot` and `ggplot` can be used to make publication quality figures, and both certainly have limitations for some types of graphics.  Arguably, ggplot excels over base graphics for data exploration and consistent syntax, and we'll explore those in the end of the lesson.  

ggplot2 Pros:| ggplot2 Cons:|
-|-|
consistent, concise syntax | different syntax from the rest of R|
intuitive (to many) | does not handle a few types of output well|
visually appealing by default | |
entirely customizable | |
Easy to standardize formatting between graphs | |

base graphics Pros:|base graphics Cons:|
-|-|
simple, straightforward for simple plots|syntax can get cumbersome for complex figures|
entirely customizable|fiddly for adjusting positions, sizes, etc.|
-|not visually appealing by default|

***




***

Parts of a ggplot plot:
-

There are several essential parts of any plot, and in `ggplot2`, they are:

1. the function: `ggplot()`
2. the arguments:
    - **data** - the dataframe
    - **aes** - the "aesthetics", or what columns to use
    - **geom** - the type of graph
    - stats
    - facets
    - scales
    - theme
    - ...and others

In `ggplot` you absolutely need the first three arguments: `data, aes, geom` to make any graphic.  The latter arguments help you customize your graphic to summarize data, express trends, or customize appearances.  We won't cover any these in much depth, but if you are comfortable with what we show you today, exploring the vast functionality of `geom, stats, scales, and theme` should be a pleasure.

***

### `ggplot()`

Some people like to assign (`<-`) their plot function to a variable, like this:

~~~
myplot<-ggplot(...)
~~~
{: .r}

***

### `data`
- This is the data you want to plot
- Must be a data.frame

For this lesson, we are going to look at the `mammals` data set that we used earlier.

~~~
head(mammals)
~~~
{: .r}

Let's **build** a scatter plot of mammal body size and litter size.

~~~
myplot<-ggplot(data=mammals... )
~~~
{: .r}


***

### `aes`
For **aes** thetics.

How your data are to be visually represented.  `aes()` is an argument within `ggplot` that takes its own arguments, `aes(x=, y=)`.  These are your independent (x) variable and your dependent (y) variable.  `ggplot2` nerds call this *mapping*.  As I understand it, they mean that you are *mapping* data points by the data values, in a 'landscape' of a coordinate system based on your data. Mapping will be important later, when we add meaningful colors and symbols to differentiate things like mice and whales, based on a variable that corresponds to one of our mapped data points.

## What happens if we make a plot just using `data` and `aes`?
~~~
myplot<-ggplot(data=mammals, aes(x=adult_body_mass_g, y=adult_head_body_len_mm))
myplot
~~~
{: .r}


If you executed this code, you probably got an blank, data-less plot. Why?

So far, we have told ggplot where to look for data (`data`), and how to represent that data (`aes`), but not what to *do* with the data values.  So there is nice space for our data... but we still need to actually plot the data.

***

## `geom`
For **geom** etry.

This is how we create the 'layer' we actually see as our figure.
These are the geometric objects likes points, lines, polygons, etc. that are in the plot

  - `geom_point()`
  - `geom_line()`
  - `geom_boxplot()`
  - `geom_text()`
  - `geom_bar()`
  - `geom_hline()`
  - 25 more!

Let's add a geom to make that scatter plot from above.

In this scatterplot, we tell ggplot to use the `mammals` dataset, to plot body mass on the x and body length on the y axis, and to plot those data as points, creating a scatterplot...

~~~
ggplot(data=mammals, aes(x=adult_body_mass_g, y=adult_head_body_len_mm))+
         geom_point()
~~~
{: .r}
![plot]({{ site.url }}/assets/r_workshop_2019/first_plot_ggplot.jpg.jpeg)


To make this code formatted neatly, with `geom_point` on the second line, simply press enter after the `+` sign. Rstudio will automatically tab into the second line. (Hint: to correctly tab any line automatically, put your cursor on the code line and type `cmd + i` (mac) or `ctrl + i ` (windows)).

 When you run this code, Rstudio will automatically recognize the + and know that the lines should run together. You should produce a plot with points displaying our data.

Plotting by order: challenges of more complex visualization
----

### Changing the aesthetics of a `geom`

This scatterplot is pretty simple. But what if we wanted to see which orders had which body sizes?


### Changing the aesthetics of a `geom`

You can easily specify which data points get a certain: color, size, shape.  You can __set__ or __map__ an visual property to your data points. But, if you __set__ it, it is *not* part of the aesthetic, because the data values have no influence on a set property.  If you __map__ that property within the aesthetic, what you see will depend on your data values.

Lets __set__ the size of the data points to make them easier to see when projected to an audience:

~~~
ggplot(data=mammals, aes(x=adult_body_mass_g, y=adult_head_body_len_mm))+
  geom_point(size=3)
~~~
{: .r}
![plot]({{ site.url }}/assets/r_workshop_2019/mass_by_length_log_pt-sz.png)


...or __map__ some **useful** color onto our values. Mapping is based on your data values, usually of a yet-unplotted variable that also describes each point or observation.  In this case, taxonomic Order is a property that describes each individual mammal in our dataset, so we can map the Order on to each data point to differentiate them:

~~~
ggplot(data=mammals, aes(x=adult_body_mass_g, y=adult_head_body_len_mm))+
  geom_point(size=3, aes(color=order))
~~~
{: .r}
![plot]({{ site.url }}/assets/r_workshop_2019/mass_len_order-color.png)

Thats a lot of orders to look at, and its hard to tell who's who.  Note however, the __automatically generated legend__.  __Yew!__  That doesn't happen in `plot` very easily, but you get it automatically in when `ggplot` maps colors or shapes to categorical variables.

To do this kind of plot without using ggplot, you would need something to this effect:
~~~
# Library to make color palettes - ggplot does this automatically
install.packages('colorspace')
library(colorspace)
# make empty plot with space for the legend
plot(adult_head_body_len_mm ~ adult_body_mass_g, data=mammals, type = 'n',
     xlim = c(0,200000000))
# get lists for order
orders = unique(mammals$order)
# make colors
colors = rainbow_hcl(length(orders))
# plot every order in a different color
for (a in 1:length(orders)) {
  dat_plot = mammals[mammals$order == orders[a],]
  points(adult_head_body_len_mm ~ adult_body_mass_g, data=dat_plot,
         col = colors[a], pch = 16)
}
# get legend in the right place, and manually set values.
legend(120000000,23000, legend = orders, col = colors, cex = 0.5, pch = 16, ncol = 2)
~~~
{: .r}
![plot]({{ site.url }}/assets/r_workshop_2019/mammals_baseplot_order.jpeg)

...ew.
